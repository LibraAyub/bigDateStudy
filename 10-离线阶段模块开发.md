# 10 -离线阶段-模块开发

## 1 数据仓库

```
维度表：维度表示你要对数据进行时所用的一个量。维度表的数据一般要结合业务情况自己写脚本按照规则生成，也可以使用工具生成，方便后续的关联分析。

事实表：表示对分析主题的度量。
```

### 1.1 维度建模

```
有三种： 
星型模式：星型模式是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样；
雪花模式：雪花模式的维度表可以拥有其他维度表的；
星座模式：是基于多张事实表的，而且共享维度信息。在业务发展后期，绝大部分维度建模都采用的是星座模式。使用最多的就是星座模式。
```
## 2 模块开发

```
窄表：对应原始数据表，字段是跟数据中一一对应
	虽然如实的记录了数据，也可以映射成功，但是不利于分析。

宽表：把某些融合各种信息的字段，提取出不同的信息作为新的字段，相对于之前的表，字段增加了；所以叫做宽表也叫做明细表。
```

### 2.1 对url的抽取

```
url:"http://cos.name/category/software/packages/" 通过一个方法就可以获取到。

create table t_ods_tmp_referurl as
SELECT a.*,b.*
FROM ods_weblog_origin a 
LATERAL VIEW parse_url_tuple(regexp_replace(http_referer, "\"", ""), 'HOST', 'PATH','QUERY', 'QUERY:id') b as host, path, query, query_id;
```

### 2.2 对日期的明细

```
date:2013-09-18 06:49:18   获取字段然后截取。


create table t_ods_tmp_detail as 
select b.*,substring(time_local,0,10) as daystr,
substring(time_local,12) as tmstr,
substring(time_local,6,2) as month,
substring(time_local,9,2) as day,
substring(time_local,11,3) as hour
From t_ods_tmp_referurl b;
```
## 3 流量分析

```
在实际生产中，究竟需要哪些统计指标通常由数据需求相关部门人员提出，
而且会不断有新的统计需求产生，以下为网站流量分析中的一些典型指标示例。
```

###  3.1 多维度统计 pv总量  

#### 		3.1.1 计算每小时 pvs，

```
group by month,day,hour：代表以每小时分组，但是必须使用聚合函数包围起来。
	select count(*) as pvs,month,day,hour from ods_weblog_detail group by month,day,hour;
```

#### 		3.1.2 计算一天各小时的pvs     

```
partitioned by:创建分区；   partition：选择分区。
```

```
create table dw_pvs_everyhour_oneday(month string,day string,hour string,pvs bigint) partitioned by(datestr string);

insert into table dw_pvs_everyhour_oneday partition(datestr='20130918')
select a.month as month,a.day as day,a.hour as hour,count(*) as pvs from ods_weblog_detail a
where  a.datestr='20130918' group by a.month,a.day,a.hour;
```

#### 		3.1.3 计算每天的pvs

```
create table dw_pvs_everyday(pvs bigint,month string,day string);

insert into table dw_pvs_everyday
select count(*) as pvs,a.month as month,a.day as day from ods_weblog_detail a
group by a.month,a.day;
```
#### 	3.1.4 hive中select中DISTINCT的技巧和使用

```
但往往只用它来返回不重复记录的条数，而不是用它来返回不重复记录的所有值。其原因是distinct只能返回它的目标字段，
列子：   
表：  id name  
1 a
2 b
3 c
4 c
5 b
	使用语句：select distinct name from table    结果是:a,b,c
	使用语句：select distinct name, id from table	结果是：1 a;2 b;3 c;4 c;5 b
这样才行：	
select *, count(distinct name) from table group by name
结果：
	id name count(distinct name)
	1 a 1
	2 b 1
	3 c 1
```

#### 	3.1.5 每小时各来访url产生的pv量

```
建表：
create table dw_pvs_referer_everyhour(referer_url string,referer_host string,month string,day string,hour string,pv_referer_cnt bigint) partitioned by(datestr string);

插入：
insert into table dw_pvs_referer_everyhour partition(datestr='20130918')
select http_referer,ref_host,month,day,hour,count(1) as pv_referer_cnt
from ods_weblog_detail 
group by http_referer,ref_host,month,day,hour 
having ref_host is not null
order by hour asc,day asc,month asc,pv_referer_cnt desc;

分析： 
	having ref_host is not null 这是代表过滤ref_host为空的部分；在写sql时，group by 要在order by的前面。其实就是分组再排序时间正序，pv_referer_cnt倒序。
	order by 中列，应该出现在group by 子句中。这是一个很显然的道理。 
	select http_referer,ref_host,month,day,hour,count(1) as pv_referer_cnt 这里就是计算每个小时的pv量然后存入给pv_referer_cnt 。
```

#### 	3.1.6 统计每小时各来访host产生的pv数并排序

```
drop table dw_pvs_refererhost_everyhour;
//创建。
create table dw_pvs_refererhost_everyhour(ref_host string,month string,day string,hour string,ref_host_cnts bigint) partitioned by(datestr string);

//插入数据。
insert into table dw_pvs_refererhost_everyhour partition(datestr='20130918')
select ref_host,month,day,hour,count(1) as ref_host_cnts
from ods_weblog_detail 
group by ref_host,month,day,hour 
having ref_host is not null
order by hour asc,day asc,month asc,ref_host_cnts desc;
```

###  3.2 人均浏览量

```
统计今日所有来访者平均请求的页面数。人均浏览量也称作人均浏览页数，该指标可以说明网站对用户的粘性。
人均页面浏览量表示用户某一时段平均浏览页面的次数。
计算方式：总页面请求数/去重总人数
create table dw_avgpv_user_everyday(
day string,
avgpv string);

insert into table dw_avgpv_user_everyday
select '20130918',sum(b.pvs)/count(b.remote_addr) from
(select remote_addr,count(1) as pvs from ods_weblog_detail where datestr='20130918' group by remote_addr) b;

```

###  3.3 统计pv总量最大的来源TOPN

```
concat（）：聚合函数，concat(month,day,hour) 将月，天，小时一样的聚合一起。
row_number()： 将一个字段进行排序并标上号。
例子：
	select ref_host,ref_host_cnts,concat(month,day,hour),
	row_number() over (partition by concat(month,day,hour) order by ref_host_cnts desc) as od 
	from dw_pvs_refererhost_everyhour;
```

#### 	3.3.1 统计一天内各小时产生最多pvs的来源topN

```
删除表：
drop table dw_pvs_refhost_topn_everyhour;

创建表：
create table dw_pvs_refhost_topn_everyhour(
hour string,
toporder string,
ref_host string,
ref_host_cnts string
)partitioned by(datestr string);

插入表：
insert into table dw_pvs_refhost_topn_everyhour partition(datestr='20130918')
select t.hour,t.od,t.ref_host,t.ref_host_cnts from
 (select ref_host,ref_host_cnts,concat(month,day,hour) as hour,
row_number() over (partition by concat(month,day,hour) order by ref_host_cnts desc) as od 
from dw_pvs_refererhost_everyhour) t where od<=3;
```

## 4 受访分析（从页面角度）

###  4.1 各页面访问统计

```
--统计各页面 pv
select request as request,count(request) as request_counts from
ods_weblog_detail group by request having request is not null order by request_counts desc limit 20;
```

### 4.2 热门页面统计

```
-统计每日最热门的页面 top10
drop table dw_hotpages_everyday;

create table dw_hotpages_everyday(day string,url string,pvs string);

insert into table dw_hotpages_everyday
select '20130918',a.request,a.request_counts from
(select request as request,count(request) as request_counts from ods_weblog_detail where datestr='20130918' 
group by request having request is not null) a
order by a.request_counts desc limit 10;
```

## 5.访客分析

### 5.1 时间维度：时

```
需求：按照时间维度来统计独立访客及其产生的pv量
删除表：
drop table dw_user_dstc_ip_h;
创建表：
create table dw_user_dstc_ip_h(
remote_addr string,
pvs      bigint,
hour     string);

插入表：时间维度：时concat(month,day,hour)
insert into table dw_user_dstc_ip_h 
select remote_addr,count(1) as pvs,concat(month,day,hour) as hour 
from ods_weblog_detail
Where datestr='20130918'
group by concat(month,day,hour),remote_addr;

在以上的基础上，可以继续分析，比如每小时独立的访客总数：
select count(1) as dstc_ip_cnts,hour from dw_user_dstc_ip_h group by hour;
```

###  5.2 时间维度：日

```
select remote_addr,count(1) as counts,concat(month,day) as day
from ods_weblog_detail
Where datestr='20130918'
group by concat(month,day),remote_addr;
```

###  5.3 时间维度：月

```
select remote_addr,count(1) as counts,month 
from ods_weblog_detail
group by month,remote_addr;
```

### 5.4每日新访客

```
将每天的新访客统计出来。实现思路：创建一个去重访客累积表，然后将每日访客对比累积表。

--历日去重访客累积表
drop table dw_user_dsct_history;
create table dw_user_dsct_history(
day string,
ip string
) 
partitioned by(datestr string);

--每日新访客表
drop table dw_user_new_d;
create table dw_user_new_d (
day string,
ip string
) 
partitioned by(datestr string);

--每日新用户插入新访客表  left outer join on  左外连接，左表连接右表，右表没有左表的字段就为null;
insert into table dw_user_new_d partition(datestr='20130918')
select tmp.day as day,tmp.today_addr as new_ip from
(
select today.day as day,today.remote_addr as today_addr,old.ip as old_addr 
from 
(select distinct remote_addr as remote_addr,"20130918" as day from ods_weblog_detail where 
datestr="20130918") today
left outer join 
dw_user_dsct_history old
on today.remote_addr=old.ip
) tmp
where tmp.old_addr is null;

--每日新用户追加到累计表
insert into table dw_user_dsct_history partition(datestr='20130918')
select day,ip from dw_user_new_d where datestr='20130918';


验证：
select count(distinct remote_addr) from ods_weblog_detail;

select count(1) from dw_user_dsct_history where datestr='20130918';

select count(1) from dw_user_new_d where datestr='20130918';
```

## 6 访客visit分析（点击流模型）

```
visit模型关注的是进入页面和离开页面，进入时间和离开时间。
```

###  6.1 回头客、单次访客统计

```
查询今日所有回头访客及其访问次数。
删除表：
drop table dw_user_returning;
创建表：
create table dw_user_returning(
day string,
remote_addr string,
acc_cnt string)
partitioned by (datestr string);

插入表：
insert overwrite table dw_user_returning partition(datestr='20130918')
select tmp.day,tmp.remote_addr,tmp.acc_cnt
from
(select '20130918' as day,remote_addr,count(session) as acc_cnt from ods_click_stream_visit group by remote_addr) tmp
where tmp.acc_cnt>1;
```

###  6.2 人均访问频次

```
select sum(pagevisits)/count(distinct remote_addr) from ods_click_stream_visit where datestr='20130918';
```

## 7 关键路径转化率分析（漏斗模型）

```
转化：在一条指定的业务流程中，各个步骤的完成人数及相对上一个步骤的百分比。我们可以分析页面标识。
tep1、 /item
Step2、 /category
Step3、 /index
Step4、 /order

UNION将多个SELECT语句的结果集合并为一个独立的结果集
```

### 7.1 查询每一个步骤的总访问人数

```
create table dw_oute_numbs as 
select 'step1' as step,count(distinct remote_addr)  as numbs from ods_click_pageviews where datestr='20130920' and request like '/item%'
union
select 'step2' as step,count(distinct remote_addr)  as numbs from ods_click_pageviews where datestr='20130920' and request like '/category%'
union
select 'step3' as step,count(distinct remote_addr)  as numbs from ods_click_pageviews where datestr='20130920' and request like '/order%'
union
select 'step4' as step,count(distinct remote_addr)  as numbs from ods_click_pageviews where datestr='20130920' and request like '/index%';
```

###  7.2查询每一步骤相对于路径起点人数的比例

```
1.级联查询，自己跟自己join
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr;

2.每一步的人数/第一步的人数==每一步相对起点人数比例
select tmp.rnstep,tmp.rnnumbs/tmp.rrnumbs as ratio
from
(
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr) tmp
where tmp.rrstep='step1';

3.查询每一步骤相对于上一步骤的漏出率  首先通过自join表过滤出每一步跟上一步的记录
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr
where cast(substr(rn.step,5,1) as int)=cast(substr(rr.step,5,1) as int)-1;

注意：cast为Hive内置函数 类型转换
select cast(1 as float); --1.0  
select cast('2016-05-22' as date); --2016-05-22 

4.然后就可以非常简单的计算出每一步相对上一步的漏出率
select tmp.rrstep as step,tmp.rrnumbs/tmp.rnnumbs as leakage_rate
from
(
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr) tmp
where cast(substr(tmp.rnstep,5,1) as int)=cast(substr(tmp.rrstep,5,1) as int)-1;
```

```
汇总以上两种指标：
select abs.step,abs.numbs,abs.rate as abs_ratio,rel.rate as leakage_rate
from 
(
select tmp.rnstep as step,tmp.rnnumbs as numbs,tmp.rnnumbs/tmp.rrnumbs as rate
from
(
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr) tmp
where tmp.rrstep='step1'
) abs
left outer join
(
select tmp.rrstep as step,tmp.rrnumbs/tmp.rnnumbs as rate
from
(
select rn.step as rnstep,rn.numbs as rnnumbs,rr.step as rrstep,rr.numbs as rrnumbs  from dw_oute_numbs rn
inner join 
dw_oute_numbs rr) tmp
where cast(substr(tmp.rnstep,5,1) as int)=cast(substr(tmp.rrstep,5,1) as int)-1
) rel
on abs.step=rel.step;
```
## 8  级联求和（累加）

```
计算消费
create table t_salary_detail(username string,month string,salary int)
row format delimited fields terminated by ',';

1、第一步，先求个用户的月总金额
select username,month,sum(salary) as salary from t_salary_detail group by username,month;

2、第二步，将月总金额表 自己连接 自己连接
select A.*,B.* FROM
(select username,month,sum(salary) as salary from t_salary_detail group by username,month) A 
inner join 
(select username,month,sum(salary) as salary from t_salary_detail group by username,month) B
on
A.username=B.username
where B.month <= A.month;

3、第三步，从上一步的结果中
进行分组查询，分组的字段是a.username a.month
求月累计值：  将b.month <= a.month的所有b.salary求和即可
select A.username,A.month,max(A.salary) as salary,sum(B.salary) as accumulate
from 
(select username,month,sum(salary) as salary from t_salary_detail group by username,month) A 
inner join 
(select username,month,sum(salary) as salary from t_salary_detail group by username,month) B
on
A.username=B.username
where B.month <= A.month
group by A.username,A.month
order by A.username,A.month;
```